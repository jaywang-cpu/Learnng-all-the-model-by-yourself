# Overview
- defination()    
- StandardScaler()  #标准化（均值0，方差1）
- MinMaxScaler()    #最小最大缩放
- RobustScaler()    #鲁棒缩放（对异常值排除在外）
- Normalizer()      #归一化
- QuantileTransformer() #分位数转换

## definition
缩放器是将不同量级的数据调整到相似范围的工具，确保算法不会被超大数值干扰产生偏差，从而保证算法公平处理每个特征。
音响调音台就像缩放器，将不同音量的乐器调整到相似范围，确保每种乐器都能被听到，不会被超大音量的鼓声干扰产生偏差，从而保证音乐的平衡和谐。

## StandardScaler() 
```
# 标准化（均值0，方差1） 把所有音量调到平均值为0，标准差为1
# 适合正态分布的数据
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
scaled_data = scaler.fit_transform(data)
# 音量：[20, 50, 80] → [-1.22, 0, 1.22]
```

## MinMaxScaler()
```
# 最小最大缩放，一般设置为0-1
# 适合知道范围的情况
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)
# 音量：[20, 50, 80] → [0, 0.5, 1]
```

## RobustScaler() 
```
# 忽略极端值，用中位数缩放
# 适合有极端值的数据
from sklearn.preprocessing import RobustScaler
scaler = RobustScaler()
scaled_data = scaler.fit_transform(data)
# 音量：[20, 50, 80, 200] → 忽略200这个异常值
```

## Normalizer
```
# 将总功率归为1
# 适合需要比较比例/偏好 而非大小的场景
from sklearn.preprocessing import Normalizer
scaler = Normalizer()
scaled_data = scaler.fit_transform(data)
# 每行音量：[3, 4] → [0.6, 0.8] (长度=1)

另外一个案例看过程
# 用户购买数据
用户A: [苹果2个, 香蕉4个, 橙子0个]
用户B: [苹果20个, 香蕉40个, 橙子0个]  # 大户

# Normalizer后
用户A: [0.45, 0.89, 0]
用户B: [0.45, 0.89, 0]
# 发现购买偏好相同，只是购买量不同
```

## QuantileTransformer
```
# 按照百分位重新分配
# 适合：任何分布的数据
from sklearn.preprocessing import QuantileTransformer
scaler = QuantileTransformer()
scaled_data = scaler.fit_transform(data)
# 把音量分布变成均匀分布或正态分布
```

| 缩放器 | 音量比喻 | 何时使用 | 范围 |
|--------|----------|----------|------|
| **StandardScaler** | 均衡器 | 正态分布 | 无固定范围 |
| **MinMaxScaler** | 音量旋钮 | 知道最值 | 0-1 |
| **RobustScaler** | 噪音消除 | 有异常值 | 无固定范围 |
| **Normalizer** | 音量平衡 | 向量长度 | 每行长度=1 |
| **QuantileTransformer** | 重新分布 | 任何分布 | 0-1或正态 |



